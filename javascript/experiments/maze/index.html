<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="A maze generated using an efficient algorithm and drawn on canvas."
    />
    <meta
      name="keywords"
      content="maze, efficient, algorithm, javascript, react, canvas"
    />

    <title>Maze</title>
  </head>
  <body>
    <div id="app"></div>

    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.development.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
    ></script>

    <script>
      (() => {
        'use strict';

        const { createElement: e } = React;

        function Canvas(props) {
          const ref = React.useRef();

          React.useEffect(() => {
            const context = '2d';
            props.onContext2d(ref.current.getContext(context));
          }, [props.onContext2d]);

          return e('canvas', {
            ref,
            width: props.width,
            height: props.height,
          });
        }

        class Cell {
          constructor(xOffset, yOffset, width, height) {
            this.xOffset = xOffset;
            this.yOffset = yOffset;
            this.width = width;
            this.height = height;
          }
        }

        function createCellGrid(cells) {
          if (typeof cells !== 'number') {
            throw new Error('cells has to be a number');
          }
          if (cells < 0) {
            throw new Error('cells has to be a non negative number');
          }

          const totalSidePercentage = 100;

          function toDecimalPercentage(percent) {
            return percent / totalSidePercentage;
          }

          // Should be less than totalSidePercentage otherwise it doesn't make
          // sense.
          const totalGapPercentage = 20;
          const totalGaps = cells + 1;
          const oneGapPercentage = toDecimalPercentage(
            totalGapPercentage / totalGaps
          );
          const totalCellPercentage = totalSidePercentage - totalGapPercentage;
          const oneCellPercentage = toDecimalPercentage(
            totalCellPercentage / cells
          );

          function calculateSideOffset(index) {
            const cellAndGap = oneCellPercentage + oneGapPercentage;

            // Append gap before the first cell.
            return cellAndGap * index + oneGapPercentage;
          }

          function calculateOffset(row, col) {
            const xOffset = calculateSideOffset(col);
            const yOffset = calculateSideOffset(row);
            const offset = { xOffset, yOffset };

            return offset;
          }

          const cellGrid = new Array(cells);

          for (let i = 0; i != cells; ++i) {
            cellGrid[i] = new Array(cells);

            for (let j = 0; j != cells; ++j) {
              const { xOffset, yOffset } = calculateOffset(i, j);

              const cell = new Cell(
                xOffset,
                yOffset,
                oneCellPercentage,
                oneCellPercentage
              );

              cellGrid[i][j] = cell;
            }
          }

          return cellGrid;
        }

        class Edge {
          constructor(vertexOne, vertexTwo, cell) {
            this.vertexOne = vertexOne;
            this.vertexTwo = vertexTwo;
            this.cell = cell;

            function createRandomPathWeight() {
              const one = 1;
              const weight = new Uint32Array(one);
              // Try to get as close to true randomness as possible.
              crypto.getRandomValues(weight);
              const only = 0;
              return weight[only];
            }

            this.weight = createRandomPathWeight();
          }
        }

        function createEdges(cellGrid) {
          let edges = [];

          function createVertex(row, column) {
            return ''.concat(row, column);
          }

          function oneLess(value) {
            return value - 1;
          }

          function exist(index) {
            return index > -1;
          }

          function reduceByHalfLength(offset, length) {
            return offset - length / 2;
          }

          function createEdgeData(cells, row) {
            cells.forEach((cell, column) => {
              const currentVertex = createVertex(row, column);

              const leftColumn = oneLess(column);
              if (exist(leftColumn)) {
                const leftVertex = createVertex(row, leftColumn);
                const xOffset = reduceByHalfLength(cell.xOffset, cell.width);
                const edgeCell = new Cell(
                  xOffset,
                  cell.yOffset,
                  cell.width,
                  cell.height
                );
                const edge = new Edge(leftVertex, currentVertex, edgeCell);

                edges.push(edge);
              }

              const topRow = oneLess(row);
              if (exist(topRow)) {
                const topVertex = createVertex(topRow, column);
                const yOffset = reduceByHalfLength(cell.yOffset, cell.height);
                const edgeCell = new Cell(
                  cell.xOffset,
                  yOffset,
                  cell.width,
                  cell.height
                );
                const edge = new Edge(topVertex, currentVertex, edgeCell);

                edges.push(edge);
              }
            });
          }

          cellGrid.forEach(createEdgeData);

          return edges;
        }

        function Maze(props) {
          const width = props.side;
          const height = props.side;

          function drawMaze(ctx) {
            const xOffset = 0;
            const yOffset = 0;

            ctx.clearRect(xOffset, yOffset, width, height);
            ctx.beginPath();

            const gapColor = 'black';
            ctx.fillStyle = gapColor;

            ctx.fillRect(xOffset, yOffset, width, height);

            function toValue(cell) {
              const value = {
                xOffset: cell.xOffset * width,
                yOffset: cell.yOffset * height,
                width: cell.width * width,
                height: cell.height * height,
              };

              return value;
            }

            function drawCell(cell) {
              const { xOffset, yOffset, width, height } = toValue(cell);
              ctx.clearRect(xOffset, yOffset, width, height);
            }

            const cellGrid = createCellGrid(props.cells);
            cellGrid.forEach((row) => row.forEach(drawCell));

            const edges = createEdges(cellGrid);

            ctx.closePath();
            ctx.stroke();
          }

          return e(Canvas, {
            width,
            height,
            onContext2d: drawMaze,
          });
        }

        function App() {
          const side = 300;
          const cells = 10;

          return e(Maze, { side, cells });
        }

        function renderApp() {
          const id = 'app';
          const domRoot = document.getElementById(id);
          ReactDOM.createRoot(domRoot).render(
            e(React.StrictMode, null, e(App))
          );
        }

        renderApp();
      })();
    </script>
  </body>
</html>
