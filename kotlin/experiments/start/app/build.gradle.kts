/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Kotlin application project to get you started.
 * For more details on building Java & JVM projects, please refer to https://docs.gradle.org/8.6/userguide/building_java_projects.html in the Gradle documentation.
 */

plugins {
    // Apply the org.jetbrains.kotlin.jvm Plugin to add support for Kotlin.
    alias(libs.plugins.jvm)

    // Apply the application plugin to add support for building a CLI application in Java.
    application

    // https://facebook.github.io/ktfmt/
    id("com.ncorti.ktfmt.gradle") version "0.17.0"
}

ktfmt {
    kotlinLangStyle()
}

repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
}

dependencies {
    // Use the Kotlin JUnit 5 integration.
    testImplementation("org.jetbrains.kotlin:kotlin-test-junit5")

    // Use the JUnit 5 integration.
    testImplementation(libs.junit.jupiter.engine)

    testRuntimeOnly("org.junit.platform:junit-platform-launcher")

    // This dependency is used by the application.
    implementation(libs.guava)

    implementation("com.github.ajalt.clikt:clikt:4.2.2")
    implementation("org.mongodb:mongodb-driver-kotlin-sync:5.0.0")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.1-Beta")
    implementation("com.squareup.retrofit2:retrofit:2.10.0")

    // Fixes: WARNING: SLF4J not found on the classpath. Logging is disabled for the 'org.bson' component
    // https://www.slf4j.org/manual.html#projectDep
    implementation("org.slf4j:slf4j-api:2.0.10")
    implementation("org.slf4j:slf4j-reload4j:2.0.10")
}

// Apply a specific Java toolchain to ease working on different environments.
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(11)
    }
}

application {
    // Define the main class for the application.
    mainClass = "org.example.AppKt"
}

tasks.named<Test>("test") {
    // Use JUnit Platform for unit tests.
    useJUnitPlatform()
}

tasks.register("listPlugins") {
    doLast {
        plugins.forEach {
            println("Plugin: ${it}")
        }
    }
}

// Tasks -- Begin

// https://docs.gradle.org/current/dsl/org.gradle.api.Task.html

// Each of the chain tasks can run independently.
// Invoking a task that depends on others will invoke dependants.
tasks.register("chainA") {
    doFirst {
        println("chain-a - the doFirst part of the task")
    }
    doLast { // Figure out what's `doLast`
        println("chainA")
    }
}

tasks.register("chainB") {
    dependsOn("chainA")
    doLast {
        println("chainB")
    }
}

tasks.register("chainC") {
    dependsOn("chainB")
    doLast {
        println("chainC")
    }
}

tasks.register("printTasks") {
    dependsOn("chainB")
    dependsOn("chainC")
    doLast {
        println("Tasks: ${tasks}")
        println("printTasks depends on")
        taskDependencies.getDependencies(this).forEach {
            println(" - ${it.name}")
        }
    }
}

// Difference between tasks.register and tasks.create
//
// https://stackoverflow.com/questions/53654190/what-is-the-difference-between-registering-and-creating-in-gradle-kotlin-dsl
// https://docs.gradle.org/current/userguide/task_configuration_avoidance.html

tasks.register("tryToGetTasks") {
    // tasks.create()
    // Project.getTasks()
    println("Are equal?; ${project.getTasks()}; ${tasks}")
}

// Is the same (i guess?) as tasks.register()
project.getTasks().register("isTheSame") {
    doLast {
        println("isTheSame - project.getTasks().register()")
    }
}

// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// See how does the `tasks.register` implementation

class MyConfiguration {
    fun propertyOne(configure: PropertyOne.(String) -> Unit) {
        val propertyOne = PropertyOne()
        propertyOne.configure("oopsie") // Where does .configure method come from?
    }
}

class PropertyOne {
    fun doSomething(action: () -> Unit) {
        action()
    }
}

class Foo {
    private val configurations = mutableMapOf<String, MyConfiguration>()

    fun add(name: String, configure: MyConfiguration.() -> Unit) {
        configurations[name] = MyConfiguration().apply(configure)
    }

    fun hm(configure: () -> Unit) {
        configure()
    }

    fun hmm(h__: () -> Unit) {
        h__()
    }
}

class Geezer {
    fun spit() {
        println("spit")
    }
    fun spit(cb: () -> Unit) {
        cb()
    }
}

fun withGeezer(geezer: Geezer.() -> Unit) {
    //geezer()
    //geezer.spit()
    Geezer().apply(geezer)
}

// Interesting, methods are callable here. Makes sense because tasks.register
// is a method.
// println("Something god")

// A class consumer of Kotlin behaviors to explore.
tasks.register("insteadOfMain") {
    doLast() {
        val foo = Foo()
        foo.add("something") {
            propertyOne {
                doSomething {
                    println("Doing something")
                }
            }
        }

        foo.add("somethingElse") {
            propertyOne { data ->
                println("let's see what happens here... ${data}")
            }
        }

        foo.hm {
            println("Hmmm...")
        }

        foo.hmm {
            println("does it work...")
        }

        // Takes in a ... something which calls println
        // It has access to geezer class methods.
        // It also calls? spit(h: () -> Unit) and provides it a callback.
        // Which effectively means `spit {}` is a method or function call which
        // takes in a callback or whatever kotlin deems it to be. The whatever
        // has access to methods of the type code defined it to have.
        withGeezer {
            println("with geezer inside")
            // Aha!
            spit() // Works
            spit {
                println("with geezer spit")
            }
        }
    }
}

// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------
// ----------------------------------------------------------------------------

// Tasks -- End

// simple task


// enhanced task

